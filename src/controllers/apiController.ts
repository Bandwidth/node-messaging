/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

import { ApiResponse } from '../apiResponse';
import { MessagingExceptionError } from '../errors/messagingExceptionError';
import { FileWrapper } from '../fileWrapper';
import { RequestOptions } from '../http/requestBuilder';
import {
  BandwidthMessage,
  bandwidthMessageSchema,
} from '../models/bandwidthMessage';
import {
  BandwidthMessagesList,
  bandwidthMessagesListSchema,
} from '../models/bandwidthMessagesList';
import { Media, mediaSchema } from '../models/media';
import { MessageRequest, messageRequestSchema } from '../models/messageRequest';
import { array, number, optional, string } from '../schema';
import { BaseController } from './baseController';

export class ApiController extends BaseController {
  /**
   * listMedia
   *
   * @param userId             User's account ID
   * @param continuationToken  Continuation token used to retrieve subsequent media.
   * @return Response from the API call
   */
  async listMedia(
    userId: string,
    continuationToken?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Media[]>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      continuationToken: [continuationToken, optional(string())],
    });
    req.header('Continuation-Token', mapped.continuationToken);
    req.appendTemplatePath`/users/${mapped.userId}/media`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.callAsJson(array(mediaSchema), requestOptions);
  }

  /**
   * getMedia
   *
   * @param userId  User's account ID
   * @param mediaId Media ID to retrieve
   * @return Response from the API call
   */
  async getMedia(
    userId: string,
    mediaId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<NodeJS.ReadableStream | Blob>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      mediaId: [mediaId, string()],
    });
    req.appendTemplatePath`/users/${mapped.userId}/media/${mapped.mediaId}`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.callAsStream(requestOptions);
  }

  /**
   * uploadMedia
   *
   * @param userId         User's account ID
   * @param mediaId        The user supplied custom media ID
   * @param contentLength  The size of the entity-body
   * @param body
   * @param contentType    The media type of the entity-body
   * @param cacheControl   General-header field is used to specify directives that MUST be obeyed by
   *                                      all caching mechanisms along the request/response chain.
   * @return Response from the API call
   */
  async uploadMedia(
    userId: string,
    mediaId: string,
    contentLength: number,
    body: FileWrapper,
    contentType?: string,
    cacheControl?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      mediaId: [mediaId, string()],
      contentLength: [contentLength, number()],
      contentType: [contentType, optional(string())],
      cacheControl: [cacheControl, optional(string())],
    });
    req.header('Content-Length', mapped.contentLength);
    req.header('Content-Type', mapped.contentType);
    req.header('Cache-Control', mapped.cacheControl);
    req.stream(body);
    req.appendTemplatePath`/users/${mapped.userId}/media/${mapped.mediaId}`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.call(requestOptions);
  }

  /**
   * deleteMedia
   *
   * @param userId  User's account ID
   * @param mediaId The media ID to delete
   * @return Response from the API call
   */
  async deleteMedia(
    userId: string,
    mediaId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      mediaId: [mediaId, string()],
    });
    req.appendTemplatePath`/users/${mapped.userId}/media/${mapped.mediaId}`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.call(requestOptions);
  }

  /**
   * getMessages
   *
   * @param userId        User's account ID
   * @param messageId     The ID of the message to search for. Special characters need to be encoded using
   *                                URL encoding
   * @param sourceTn      The phone number that sent the message
   * @param destinationTn The phone number that received the message
   * @param messageStatus The status of the message. One of RECEIVED, QUEUED, SENDING, SENT, FAILED,
   *                                DELIVERED, DLR_EXPIRED
   * @param errorCode     The error code of the message
   * @param fromDateTime  The start of the date range to search in ISO 8601 format. Uses the message receive
   *                                time. The date range to search in is currently 14 days.
   * @param toDateTime    The end of the date range to search in ISO 8601 format. Uses the message receive
   *                                time. The date range to search in is currently 14 days.
   * @param pageToken     A base64 encoded value used for pagination of results
   * @param limit         The maximum records requested in search result. Default 100. The sum of limit and
   *                                after cannot be more than 10000
   * @return Response from the API call
   */
  async getMessages(
    userId: string,
    messageId?: string,
    sourceTn?: string,
    destinationTn?: string,
    messageStatus?: string,
    errorCode?: number,
    fromDateTime?: string,
    toDateTime?: string,
    pageToken?: string,
    limit?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<BandwidthMessagesList>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      messageId: [messageId, optional(string())],
      sourceTn: [sourceTn, optional(string())],
      destinationTn: [destinationTn, optional(string())],
      messageStatus: [messageStatus, optional(string())],
      errorCode: [errorCode, optional(number())],
      fromDateTime: [fromDateTime, optional(string())],
      toDateTime: [toDateTime, optional(string())],
      pageToken: [pageToken, optional(string())],
      limit: [limit, optional(number())],
    });
    req.query('messageId', mapped.messageId);
    req.query('sourceTn', mapped.sourceTn);
    req.query('destinationTn', mapped.destinationTn);
    req.query('messageStatus', mapped.messageStatus);
    req.query('errorCode', mapped.errorCode);
    req.query('fromDateTime', mapped.fromDateTime);
    req.query('toDateTime', mapped.toDateTime);
    req.query('pageToken', mapped.pageToken);
    req.query('limit', mapped.limit);
    req.appendTemplatePath`/users/${mapped.userId}/messages`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.callAsJson(bandwidthMessagesListSchema, requestOptions);
  }

  /**
   * createMessage
   *
   * @param userId User's account ID
   * @param body
   * @return Response from the API call
   */
  async createMessage(
    userId: string,
    body: MessageRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<BandwidthMessage>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      body: [body, messageRequestSchema],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/users/${mapped.userId}/messages`;
    req.throwOn(400, MessagingExceptionError, '400 Request is malformed or invalid');
    req.throwOn(401, MessagingExceptionError, '401 The specified user does not have access to the account');
    req.throwOn(403, MessagingExceptionError, '403 The user does not have access to this API');
    req.throwOn(404, MessagingExceptionError, '404 Path not found');
    req.throwOn(415, MessagingExceptionError, '415 The content-type of the request is incorrect');
    req.throwOn(429, MessagingExceptionError, '429 The rate limit has been reached');
    return req.callAsJson(bandwidthMessageSchema, requestOptions);
  }
}
